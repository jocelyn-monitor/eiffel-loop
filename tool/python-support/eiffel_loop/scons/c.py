#	author: "Finnian Reilly"
#	copyright: "Copyright (c) 2001-2012 Finnian Reilly"
#	contact: "finnian at eiffel hyphen loop dot com"
#	license: "MIT license (See: en.wikipedia.org/wiki/MIT_License)"
#	date: "16 Dec 2011"
#	revision: "0.1"

import os, subprocess
from os import path

from SCons.Script.SConscript import Configure


def put_export_entry (fout, line):
	if len (line) > 26:
		fout.write ('\t%s\n' % line [26:])

def drop_line (fout, line):
	pass

def write_dll_definitions (dll_path, def_path):
	cmd = ['dumpbin','/EXPORTS', dll_path]
	print cmd
	proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)

	fout = open (def_path, 'w')
	fout.write ('LIBRARY %s\n' % path.basename (dll_path))
	fout.write ('EXPORTS\n')

	done = False
	fn_put = drop_line
	while not done:
		line = proc.stdout.readline()
		if len (line) == 0:
			done = True

		elif line.find ('ordinal hint') > 0:
			fn_put = put_export_entry

		elif line.find ('Summary') > 0:
			fn_put = drop_line

		else:
			fn_put (fout, line.rstrip())
	
	fout.write ('\n')
	fout.close


# Convert Windows dll to def

def dll_def_generator (target, source, env):
	for i in range (0, len (source)):
		def_src_path = str (source [i])
		f_in = open (def_src_path, 'r')
		dll_name = f_in.readline ().rstrip()
		f_in.close
		target_dir = path.dirname (str (target [i]))
		dll_path = path.join (target_dir, dll_name)
		write_dll_definitions (dll_path, str (target [i]))


def has_ansi_C_standard_headers (conf):
	result = True
	# if the system has these, it probably has the rest of the ANSI C header files.
	for h in ['stdlib.h', 'stdarg.h', 'string.h', 'float.h']:
		if conf.CheckCHeader (h):
			pass
		else:
			result = False
			break
	return result
	
class CONFIG_HEADER (object):

	def __init__(self, conf, location):
		self.config_h = open (path.join (location, 'config.h'), 'w')
		self.config_h.write ('// Generated by SCons\n')
		self.config_h.write ('// Do not edit\n\n')
		self.conf = conf
		
	def __write_defines_for_header_availability (self, headers, check):
		for h in headers:
			header_id = None
			h = path.normpath (h)
			for s in path.splitext (h)[0].split (os.sep):
				if header_id:
					header_id = header_id + '_' + s
				else:
					header_id = s
					
			self.config_h.write ('/* Define to 1 if you have the <%s> header file. */\n' % h)
			if check (h):
				self.config_h.write ('#define HAVE_%s 1\n\n' % header_id.upper ())
				if h == 'locale.h':
					self.config_h.write ('#define HAVE_LC_MESSAGES 1\n\n')
			
			else:
				self.config_h.write ('/* #undef HAVE_%s */\n\n' % header_id.upper ())
		
	def close (self):
		self.config_h.close
		
	def write_defines_for_C_header_availability (self, headers):
		self.__write_defines_for_header_availability (headers, self.conf.CheckCHeader)

	def write_defines_for_CPP_header_availability (self, headers):
		self.__write_defines_for_header_availability (headers, self.conf.CheckCXXHeader)
				
	def write_defines_for_C_library_availability (self, libraries):
		for lib in libraries:
			self.config_h.write ('/* Define to 1 if you have the \'%s\' library. (-l%s) */\n' % (lib, lib))
			if self.conf.CheckLib (lib):
				self.config_h.write ('#define HAVE_LIB%s 1\n\n' % lib.upper ())

	def write_defines_for_C_function_availability (self, functions):
		for func in functions:
			self.config_h.write ('/* Define to 1 if you have the \'%s\' function.*/\n' % func)
			if self.conf.CheckFunc (func):
				self.config_h.write ('#define HAVE_%s 1\n\n' % func.upper ())
			else:
				self.config_h.write ('/* #undef HAVE_%s */\n\n' % func.upper ())

	def write_string_defines (self, define_tuples):
		for macro_name, str_value, description in define_tuples:
			if description:
				self.config_h.write ('/* Define to the %s */\n' % description)
			self.config_h.write ('#define %s "%s"\n\n' % (macro_name, str_value))
			
	def write_defines (self, define_tuples):
		for macro_name, value, description in define_tuples:
			if description:
				self.config_h.write ('/* Define to %s %s */\n' % (value, description))
			self.config_h.write ('#define %s %s\n\n' % (macro_name, value))
			
	def write (self, str):
		self.config_h.write (str)
		
			

